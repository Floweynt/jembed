package com.floweytf.jvmir;

import org.jetbrains.annotations.ApiStatus;
import org.jetbrains.annotations.Nullable;
import org.objectweb.asm.MethodVisitor;
import org.objectweb.asm.Type;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Objects;
import java.util.stream.Stream;

public final class InstrNode {
    private final List<InstrNode> operands;
    @Nullable
    private Instr instr;
    @Nullable
    private InstrNode chain;

    private boolean isFrozen = false;

    @ApiStatus.Internal
    public InstrNode(List<InstrNode> operands, @Nullable Instr instr) {
        this.operands = new ArrayList<>(operands);

        if (instr != null) {
            if (instr.node != null)
                throw new IllegalArgumentException();
            instr.node = this;
            this.instr = instr;
        }
    }

    private void ensureMutable() {
        if (isFrozen)
            throw new UnsupportedOperationException("cannot modify frozen instruction!");
    }

    // misc
    public @Nullable Instr instr() {
        return instr;
    }

    public @Nullable Instr replaceInstr(Instr other) {
        ensureMutable();

        // ensure that instructions have the correct properties...
        other.node = this;
        if (instr != null) {
            instr.node = null;
        }

        var currInstr = instr;
        instr = other;
        return currInstr;
    }

    // Chains represent a data dependency generated by some side effect
    // All local load/store operations of the same local must be chained together
    // There is also another type of chain, denoted as "M" for memory
    // Example "M" type chains:
    // Function call
    // Load/store to field
    // ... etc

    public @Nullable InstrNode chain() {
        return chain;
    }

    public void chain(@Nullable InstrNode chain) {
        this.chain = chain;
    }

    public void freeze() {
        isFrozen = true;
    }

    // operand management
    public InstrNode getOperand(int i) {
        return operands.get(i);
    }

    public void setOperand(int i, InstrNode node) {
        ensureMutable();
        operands.set(i, node);
    }

    public void addOperand(int i, InstrNode node) {
        operands.add(i, node);
    }

    public void addOperand(InstrNode node) {
        operands.add(node);
    }

    public List<InstrNode> operands() {
        return Collections.unmodifiableList(operands);
    }

    public Stream<InstrNode> dependants() {
        var ret = operands.stream();
        if (chain != null) {
            ret = Stream.concat(Stream.of(chain), ret);
        }

        return ret;
    }

    // Utility methods to call stuff from Instr
    public @Nullable String getOperandName(int i) {
        return Objects.requireNonNull(instr).getOperandName(i);
    }

    public String name() {
        return Objects.requireNonNull(instr).name();
    }

    public List<Object> getImmOperands() {
        return Objects.requireNonNull(instr).getImmOperands();
    }

    public List<String> getImmNames() {
        return Objects.requireNonNull(instr).getImmNames();
    }

    public @Nullable Type type() {
        return Objects.requireNonNull(instr).type();
    }

    public void emit(BlockInstrWriter writer) {
        Objects.requireNonNull(instr).emit(writer);
    }

    public void runChecks() {
        Objects.requireNonNull(instr).runChecks();
    }
}